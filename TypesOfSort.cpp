#include <iostream>
using namespace std;
int SIZE = 7;

void showArr(int array[])
{
    for (int i = 0; i < SIZE; i++) 
	{
		cout << array[i] << " ";
	}
    cout << endl;
}

void bubbleSort(int ar[])//Сортировка пузырьком
{
    //последовательно сравнивать значения соседних элементов 
    // и менять числа местами, 
    // если предыдущее оказывается больше последующего
    bool flag = false;
    for (int i = 0,n=SIZE; i < n-i; i++) {
        flag = true;
        for (int j = 0,n= SIZE; j < n-i-1; j++) {
            if (ar[j] > ar[j+1]) {
                swap(ar[j], ar[j+1]);
                flag = false;
            }

        }
        if (flag)break;
    }
}

void insertSort(int ar[]) {//Сортировка вставками
    //на каждом шаге массив постепенно перебирается слева направо. 
    // При этом каждый последующий элемент размещается так, 
    // чтобы он оказался между ближайшими элементами с минимальным и максимальным значением
    for (int i = 1; i < SIZE; i++)
    {
        for (int j = i; j > 0; j--) 
        {
            if (ar[j] < ar[j-1]) 
            {
                swap(ar[j] , ar[j-1]);
                
            }
            else 
            {
                break;
            }
        }
    }
}

void quickSort(int array[], int low, int high) {
    
    if (low < high) {
        // Разделение массива и получение индекса опоры
        int pivot = array[high]; // Опорный элемент
        int i = low - 1; // Индекс меньшего элемента

        for (int j = low; j < high; j++) {
            // Если текущий элемент меньше или равен опорному
            if (array[j] <= pivot) {
                i++; // Увеличиваем индекс меньшего элемента
                swap(array[i], array[j]); // Меняем местами
            }
        }
        swap(array[i + 1], array[high]); // Перемещаем опорный элемент на правильную позицию
        int pi = i + 1; // Индекс опоры

        // Рекурсивно сортируем элементы до и после опорного элемента
        quickSort(array, low, pi - 1);
        quickSort(array, pi + 1, high);
    }
}

int binarySearch(int ar[], int size, int target) {//Бинарный поиск
    //Бинарный поиск — это алгоритм для поиска элемента в отсортированном массиве.
    int left = 0; // Начальный индекс левой границы
    int right = size - 1; // Начальный индекс правой границы

    while (left <= right) { // Пока левая граница не превышает правую
        int mid = left + (right - left) / 2; // Находим средний индекс

        if (ar[mid] == target) { // Если элемент в середине равен искомому значению
            return mid; // Возвращаем индекс найденного элемента
        }

        if (ar[mid] < target) { // Если средний элемент меньше искомого значения
            left = mid + 1; // Сдвигаем левую границу вправо
        }
        else { // Если средний элемент больше искомого
            right = mid - 1; // Сдвигаем правую границу влево
        }
    }

    return -1; // Если элемент не найден, возвращаем -1
}

// Функция для сортировки слиянием
void mergeSort(int ar[], int size) { // Определяем функцию с параметрами массива и его размера
    //Принцип работы:
    //1. Разделение: 
    // -Массив рекурсивно делится на две половины, пока не останется массивы размером 1

    //2. Слияние:
    //-Отсортированные половины объединяются(сливаются) в один отсортированный массив.
    //- Слияние происходит с помощью сравнения элементов из 
    // обеих половин и поочередного добавления меньшего элемента в новый массив.

    if (size < 2) return; // Если размер меньше 2, просто возвращаем

    int mid = size / 2; // Находим середину массива

    // Создаем временные массивы
    int* L = new int[mid]; // Левый массив
    int* R = new int[size - mid]; // Правый массив

    // Копируем данные во временные массивы
    for (int i = 0; i < mid; i++) L[i] = ar[i]; // Заполнение левого массива
    for (int j = mid; j < size; j++) R[j - mid] = ar[j]; // Заполнение правого массива

    // Рекурсивно сортируем каждую половину
    mergeSort(L, mid); // Сортируем левую половину
    mergeSort(R, size - mid); // Сортируем правую половину

    // Индексы для обхода массивов
    int i = 0, j = 0, k = 0; // Индексы для L, R и исходного массива

    // Слияние временных массивов обратно в ar[]
    while (i < mid && j < size - mid) { // Пока не достигнут конец одного массива
        if (L[i] <= R[j]) ar[k++] = L[i++]; // Если элемент L меньше, копируем в ar
        else ar[k++] = R[j++]; // Иначе копируем элемент из R
    }

    // Копируем оставшиеся элементы, если есть
    while (i < mid) ar[k++] = L[i++]; // Копируем остаток из L
    while (j < size - mid) ar[k++] = R[j++]; // Копируем остаток из R

    delete[] L; // Освобождаем память для L
    delete[] R; // Освобождаем память для R
}

int main()
{
	setlocale(LC_ALL, "rus");
	int array[] = { 10,23,7,34,12,55,99 };
	showArr(array);
    mergeSort(array,SIZE);
    showArr(array);
}
